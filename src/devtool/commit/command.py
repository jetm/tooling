"""devtool commit â€” AI-powered commit message generation."""

from __future__ import annotations

import fnmatch
import logging
import os
import re
import shutil
import subprocess
import sys
from pathlib import Path
from typing import TYPE_CHECKING

import click
from rich.markup import escape as rich_escape

if TYPE_CHECKING:
    import git
    from rich.console import Console

    from devtool.common.config import ACAConfig

logger = logging.getLogger(__name__)


# =============================================================================
# Diff Compression Module
# =============================================================================

COMPRESSION_EXCLUDE_PATTERNS: set[str] = {
    # Binary files
    "*.png",
    "*.jpg",
    "*.jpeg",
    "*.gif",
    "*.ico",
    "*.webp",
    "*.svg",
    "*.pdf",
    "*.woff",
    "*.woff2",
    "*.ttf",
    "*.eot",
    "*.otf",
    "*.zip",
    "*.tar",
    "*.gz",
    "*.bz2",
    "*.7z",
    "*.rar",
    "*.exe",
    "*.dll",
    "*.so",
    "*.dylib",
    "*.bin",
    # Lock files
    "package-lock.json",
    "yarn.lock",
    "pnpm-lock.yaml",
    "Cargo.lock",
    "poetry.lock",
    "Gemfile.lock",
    "composer.lock",
    "Pipfile.lock",
    "uv.lock",
    # Minified files
    "*.min.js",
    "*.min.css",
    "*.bundle.js",
    "*.bundle.css",
    # Generated files
    "*-generated.*",
    "*.pb.go",
    "*.pb.h",
    "*.pb.cc",
    "*.pb.py",
    "*.g.dart",
    "*.freezed.dart",
    "*.generated.ts",
}

FILE_PRIORITY_PATTERNS: dict[str, dict[str, int]] = {
    "high": {
        "*.py": 100,
        "*.ts": 100,
        "*.tsx": 100,
        "*.js": 100,
        "*.jsx": 100,
        "*.go": 100,
        "*.rs": 100,
        "*.java": 100,
        "*.c": 100,
        "*.cpp": 100,
        "*.h": 100,
        "*.hpp": 100,
        "*.rb": 100,
        "*.php": 100,
        "*.cs": 100,
        "*.swift": 100,
        "*.kt": 100,
    },
    "medium": {
        "*.yaml": 50,
        "*.yml": 50,
        "*.toml": 50,
        "*.json": 50,
        "*.md": 50,
        "*.rst": 50,
        "*.txt": 50,
        "Dockerfile": 50,
        "Makefile": 50,
        "*.sh": 50,
        "*.bash": 50,
    },
    "low": {
        "*.lock": 10,
        "*.sum": 10,
        "*.mod": 10,
        "package.json": 10,
        "pyproject.toml": 10,
        ".gitignore": 10,
        ".dockerignore": 10,
    },
}

AUTO_GENERATED_INDICATORS: set[str] = {
    "@generated",
    "auto-generated",
    "autogenerated",
    "do not edit",
    "do not modify",
    "generated by",
    "code generated",
    "*.pb.go",
    "*.pb.h",
    "*.pb.cc",
    "*.pb.py",
    "*.g.dart",
    "*.freezed.dart",
    "*.generated.ts",
    "*_generated.*",
}


def score_file_priority(filepath: str, file_content_sample: str | None = None) -> int:
    """Score a file's priority for smart compression."""
    filename = filepath.split("/")[-1]

    for pattern in COMPRESSION_EXCLUDE_PATTERNS:
        if fnmatch.fnmatch(filename, pattern) or fnmatch.fnmatch(filepath, pattern):
            return 0

    for indicator in AUTO_GENERATED_INDICATORS:
        if indicator.startswith("*"):
            if fnmatch.fnmatch(filename, indicator) or fnmatch.fnmatch(filepath, indicator):
                return 5

    is_auto_generated = False
    if file_content_sample:
        content_to_check = file_content_sample.lower()[:2000]
        for indicator in AUTO_GENERATED_INDICATORS:
            if not indicator.startswith("*") and indicator in content_to_check:
                is_auto_generated = True
                break

    base_score = 25
    pattern_matched = False

    for _priority_level, patterns in FILE_PRIORITY_PATTERNS.items():
        for pattern, score in patterns.items():
            if "*" not in pattern and "?" not in pattern:
                if filename == pattern or filepath == pattern or filepath.endswith("/" + pattern):
                    base_score = score
                    pattern_matched = True
                    break
        if pattern_matched:
            break

    if not pattern_matched:
        for _priority_level, patterns in FILE_PRIORITY_PATTERNS.items():
            for pattern, score in patterns.items():
                if "*" in pattern or "?" in pattern:
                    if fnmatch.fnmatch(filename, pattern) or fnmatch.fnmatch(filepath, pattern):
                        base_score = score
                        pattern_matched = True
                        break
            if pattern_matched:
                break

    path_lower = filepath.lower()
    if any(d in path_lower for d in ["tests/", "test/", "__tests__/", "_test."]):
        base_score = int(base_score * 0.8)
    elif any(d in path_lower for d in ["docs/", "documentation/"]):
        base_score = int(base_score * 0.7)
    elif any(d in path_lower for d in ["scripts/", "tools/"]):
        base_score = int(base_score * 0.9)

    if is_auto_generated:
        base_score = int(base_score * 0.5)

    return base_score


def calculate_diff_size(diff_output: str, repo: git.Repo | None = None) -> dict[str, int]:
    """Calculate size metrics for a git diff output."""
    import git as gitmodule

    if repo is not None and isinstance(repo, gitmodule.Repo):
        try:
            name_only_output = repo.git.diff("--cached", "--name-only")
            file_count = len(name_only_output.strip().split("\n")) if name_only_output.strip() else 0
        except gitmodule.exc.GitCommandError:
            file_count = len(re.findall(r"^diff --git", diff_output, re.MULTILINE))
    else:
        file_count = len(re.findall(r"^diff --git", diff_output, re.MULTILINE))

    return {
        "bytes": len(diff_output.encode("utf-8")),
        "chars": len(diff_output),
        "lines": diff_output.count("\n"),
        "files": file_count,
    }


def extract_diff_statistics(repo: git.Repo) -> dict[str, int]:
    """Extract insertion/deletion statistics from staged changes."""
    import git as gitmodule

    result = {"insertions": 0, "deletions": 0, "files_changed": 0}
    if not isinstance(repo, gitmodule.Repo):
        return result

    try:
        stat_output = repo.git.diff("--cached", "--stat")
        if not stat_output.strip():
            return result

        lines = stat_output.strip().split("\n")
        summary_line = lines[-1] if lines else ""

        files_match = re.search(r"(\d+)\s+files?\s+changed", summary_line)
        if files_match:
            result["files_changed"] = int(files_match.group(1))

        ins_match = re.search(r"(\d+)\s+insertions?\(\+\)", summary_line)
        if ins_match:
            result["insertions"] = int(ins_match.group(1))

        del_match = re.search(r"(\d+)\s+deletions?\(-\)", summary_line)
        if del_match:
            result["deletions"] = int(del_match.group(1))
    except gitmodule.exc.GitCommandError:
        logger.debug("Failed to get diff statistics", exc_info=True)

    return result


def should_compress_diff(diff_size: dict[str, int], config: ACAConfig) -> bool:
    """Determine if diff compression should be applied based on thresholds."""
    return diff_size["bytes"] > config.diff_size_threshold_bytes or diff_size["files"] > config.diff_files_threshold


def compress_diff_stat(repo: git.Repo) -> str:
    """Compress diff using statistical summary."""
    result = repo.git.diff("--cached", "--stat")
    return result if result else "No changes staged"


def compress_diff_compact(repo: git.Repo) -> str:
    """Compress diff using minimal context."""
    result = repo.git.diff("--cached", "--compact-summary", "-U1")
    return result if result else "No changes staged"


def compress_diff_filtered(repo: git.Repo) -> tuple[str, int, int]:
    """Compress diff by excluding generated and binary files."""
    all_files = repo.git.diff("--cached", "--name-only").splitlines()
    if not all_files:
        return "No changes staged", 0, 0

    binary_files: set[str] = set()
    numstat_output = repo.git.diff("--cached", "--numstat").splitlines()
    for line in numstat_output:
        parts = line.split("\t")
        if len(parts) >= 3 and parts[0] == "-" and parts[1] == "-":
            binary_files.add(parts[2])

    included_files: list[str] = []
    excluded_files: list[str] = []

    for filepath in all_files:
        if filepath in binary_files:
            excluded_files.append(filepath)
            continue
        filename = filepath.split("/")[-1]
        excluded = any(
            fnmatch.fnmatch(filename, p) or fnmatch.fnmatch(filepath, p) for p in COMPRESSION_EXCLUDE_PATTERNS
        )
        if excluded:
            excluded_files.append(filepath)
        else:
            included_files.append(filepath)

    if not included_files:
        stat_summary = repo.git.diff("--cached", "--stat")
        return f"All files matched exclusion patterns. Summary:\n{stat_summary}", 0, len(excluded_files)

    result = repo.git.diff("--cached", "--", *included_files)
    return result if result else "No changes in included files", len(included_files), len(excluded_files)


def compress_diff_function_context(repo: git.Repo) -> str:
    """Compress diff using function context format."""
    result = repo.git.diff("--cached", "--function-context")
    return result if result else "No changes staged"


def compress_diff_smart(repo: git.Repo, config: ACAConfig) -> tuple[str, int, int, int]:
    """Compress diff using smart file prioritization."""
    import git as gitmodule

    all_files = repo.git.diff("--cached", "--name-only").splitlines()
    if not all_files:
        return "No changes staged", 0, 0, 0

    scored_files: list[tuple[str, int]] = []
    for filepath in all_files:
        content_sample: str | None = None
        try:
            raw_content = repo.git.show(f":0:{filepath}")
            content_sample = raw_content[:1000] if raw_content else None
        except gitmodule.GitCommandError:
            pass
        except UnicodeDecodeError:
            pass

        score = score_file_priority(filepath, content_sample)
        if score > 0:
            scored_files.append((filepath, score))

    if not scored_files:
        stat_summary = repo.git.diff("--cached", "--stat")
        return f"All files matched exclusion patterns. Summary:\n{stat_summary}", 0, len(all_files), len(stat_summary)

    scored_files.sort(key=lambda x: x[1], reverse=True)

    max_priority = config.diff_max_priority_files
    token_limit = config.diff_token_limit
    excluded_files = [f for f in all_files if f not in [sf[0] for sf in scored_files]]

    max_iterations = 3
    current_priority_count = min(max_priority, len(scored_files))
    demoted_files: set[str] = set()

    for _iteration in range(max_iterations):
        output_parts: list[str] = []

        eligible_files = [(f, s) for f, s in scored_files if f not in demoted_files]
        current_priority_files = [f for f, _ in eligible_files[:current_priority_count]]

        output_parts.append("# Smart Compressed Diff")
        output_parts.append(f"# Priority files (full diff): {len(current_priority_files)}")
        output_parts.append(f"# Summary files (stat only): {len(scored_files) - len(current_priority_files)}")
        output_parts.append("")
        output_parts.append("## Priority Files (Full Diff)")
        output_parts.append("")

        files_over_limit: list[str] = []

        for filepath in current_priority_files:
            try:
                file_diff = repo.git.diff("--cached", "-U3", "--", filepath)
                if file_diff:
                    output_parts.append(file_diff)
                    output_parts.append("")
                    current_length = sum(len(p) for p in output_parts)
                    if current_length > token_limit:
                        files_over_limit.append(filepath)
            except gitmodule.GitCommandError:
                pass

        if files_over_limit:
            demoted_files.update(files_over_limit)
            current_priority_count = max(1, current_priority_count - len(files_over_limit))
            continue

        remaining_to_stat = (
            [f for f, _ in eligible_files[len(current_priority_files) :]] + list(demoted_files) + excluded_files
        )
        if remaining_to_stat:
            output_parts.append("")
            output_parts.append("## Remaining Files (Summary)")
            output_parts.append("")
            try:
                stat_output = repo.git.diff("--cached", "--stat", "--", *remaining_to_stat)
                if stat_output:
                    output_parts.append(stat_output)
            except gitmodule.GitCommandError:
                output_parts.append("(Unable to generate stat summary)")

        final_output = "\n".join(output_parts)
        char_count = len(final_output)

        if char_count <= token_limit:
            return final_output, len(current_priority_files), len(remaining_to_stat), char_count

        current_priority_count = max(1, int(current_priority_count * 0.8))

    stat_output = repo.git.diff("--cached", "--stat")
    header = f"# Smart Compression Fallback (diff exceeded {token_limit} char limit)\n\n"
    fallback_output = header + stat_output
    return fallback_output, 0, len(all_files), len(fallback_output)


def apply_compression_strategy(
    repo: git.Repo,
    strategy: str,
    original_diff: str,
    config: ACAConfig | None = None,
) -> tuple[str, dict[str, int | str]]:
    """Apply the specified compression strategy to the diff."""
    import git as gitmodule

    if config is None:
        from devtool.common.config import get_config

        config = get_config()

    original_size = len(original_diff.encode("utf-8"))
    files_included = 0
    files_excluded = 0
    char_count = 0

    try:
        match strategy:
            case "stat":
                compressed_diff = compress_diff_stat(repo)
            case "compact":
                compressed_diff = compress_diff_compact(repo)
            case "filtered":
                compressed_diff, files_included, files_excluded = compress_diff_filtered(repo)
            case "function-context":
                compressed_diff = compress_diff_function_context(repo)
            case "smart":
                compressed_diff, files_included, files_excluded, char_count = compress_diff_smart(repo, config)
            case _:
                logger.warning(f"Unknown compression strategy '{strategy}', falling back to 'compact'")
                compressed_diff = compress_diff_compact(repo)
                strategy = "compact"

        compressed_size = len(compressed_diff.encode("utf-8"))

        compression_info: dict[str, int | str] = {
            "strategy": strategy,
            "original_size": original_size,
            "compressed_size": compressed_size,
            "files_included": files_included,
            "files_excluded": files_excluded,
        }

        if strategy == "smart":
            compression_info["char_count"] = char_count
            compression_info["token_limit"] = config.diff_token_limit

        return compressed_diff, compression_info

    except gitmodule.GitCommandError as e:
        logger.error(f"Git command failed during compression: {e}")
        return original_diff, {
            "strategy": "none",
            "original_size": original_size,
            "compressed_size": original_size,
            "files_included": 0,
            "files_excluded": 0,
        }


def run_precommit_hooks(repo: git.Repo, console: Console, staged_files: list[str]) -> tuple[bool, list[str]]:
    """Run pre-commit hooks on staged files."""
    from devtool.common.git import get_precommit_skip_env

    if not shutil.which("pre-commit"):
        console.print("[dim]pre-commit not found, skipping hook validation[/dim]")
        return True, []

    config_path = Path(repo.working_dir) / ".pre-commit-config.yaml"
    if not config_path.is_file():
        console.print("[dim]No .pre-commit-config.yaml found, skipping hook validation[/dim]")
        return True, []

    if not staged_files:
        return True, []

    skip_env = get_precommit_skip_env()
    if skip_env:
        console.print("[yellow]âš  Skipping pre-commit hooks (SKIP_PRECOMMIT is set)[/yellow]")
        return True, []

    try:
        pre_hook_unstaged_output = repo.git.diff("--name-only")
        pre_hook_unstaged = {f for f in pre_hook_unstaged_output.split("\n") if f.strip()}
    except Exception:
        pre_hook_unstaged = set()

    cmd = ["pre-commit", "run", "--files"] + staged_files
    env = os.environ.copy()
    result = subprocess.run(cmd, capture_output=True, text=True, cwd=repo.working_dir, env=env)

    modified_files: list[str] = []
    try:
        post_hook_unstaged_output = repo.git.diff("--name-only")
        post_hook_unstaged = {f for f in post_hook_unstaged_output.split("\n") if f.strip()}
        new_unstaged = post_hook_unstaged - pre_hook_unstaged
        staged_set = set(staged_files)
        modified_files = sorted(new_unstaged & staged_set)
    except Exception:
        pass

    if result.returncode == 0:
        return True, modified_files

    console.print("\n[red bold]Pre-commit hooks failed:[/red bold]\n")
    if result.stdout:
        console.print(rich_escape(result.stdout))
    if result.stderr:
        console.print(f"[red]{rich_escape(result.stderr)}[/red]")

    return False, modified_files


def extract_commit_message(text: str) -> str | None:
    """Extract clean commit message from Claude's response."""
    text = text.strip()
    if not text:
        return None

    fence_pattern = re.compile(r"^```[a-zA-Z0-9_ ]*$")
    lines = text.split("\n")

    in_fence = False
    fence_content: list[str] = []
    for line in lines:
        if fence_pattern.match(line.strip()):
            if not in_fence:
                in_fence = True
                fence_content = []
            else:
                result = "\n".join(fence_content).strip()
                if result:
                    return result
                in_fence = False
                fence_content = []
        elif in_fence:
            fence_content.append(line)

    preamble_patterns = [
        re.compile(r"^here\s+(is|are)\s+(the\s+)?(commit\s+)?message", re.IGNORECASE),
        re.compile(r"^(the\s+)?commit\s+message\s*(is|:)", re.IGNORECASE),
        re.compile(r"^i('ve|'ll| have| will| would)", re.IGNORECASE),
        re.compile(r"^(sure|okay|certainly|of course)[,!.]?\s*", re.IGNORECASE),
        re.compile(r"^based on (the |your )?", re.IGNORECASE),
        re.compile(r"^(let me|allow me)", re.IGNORECASE),
    ]

    result_lines: list[str] = []
    found_content = False

    for line in lines:
        stripped = line.strip()

        if not stripped and not found_content:
            continue

        is_preamble = any(pattern.match(stripped) for pattern in preamble_patterns)

        if is_preamble and not found_content:
            continue

        if stripped.endswith(":") and not found_content:
            continue

        if stripped:
            found_content = True

        if not stripped and found_content and result_lines:
            result_lines.append(line)
            continue

        if found_content:
            result_lines.append(line)

    result = "\n".join(result_lines).strip()
    return result if result else None


def truncate_title(title: str, max_length: int = 75) -> str:
    """Truncate a commit title to max_length, cutting at word boundary."""
    title = title.split("\n")[0].strip()
    if len(title) <= max_length:
        return title
    truncated = title[:max_length]
    last_space = truncated.rfind(" ")
    if last_space > max_length // 2:
        return truncated[:last_space]
    return truncated


# =============================================================================
# Prompt Templates
# =============================================================================

COMMIT_PROMPT = """## Generate Commit Message

Analyze the diff output and generate a commit message following these rules strictly:

### Format & Style

## Subject Line:
- Start with the correct subsystem prefix based on the file paths (e.g., `iotil/rest:`, `iotil/compliance:`, `drivers/net:`, `mm:`)
- Be imperative (e.g., "Fix memory leak" not "Fixed memory leak")
- Capitalize the first letter after the prefix
- No trailing period
- Limit to 70-75 characters

Body:
- Wrap text strictly at 72 characters
- Separate the subject from the body with a blank line
- Use the imperative mood throughout

### Diff Format

The diff may be provided in one of these formats:
- **Full diff**: Complete unified diff with all changes
- **Statistical summary** (`--stat`): File-level summary showing files changed and line counts
- **Compact diff** (`-U1`): Minimal context (1 line) around changes
- **Filtered diff**: Source files only, excluding generated/binary files
- **Function context**: Complete functions/classes where changes occurred
- **Smart compression**: Hybrid format with full diff for priority source files (10-15 files) and statistical summary for remaining files

Regardless of format, focus on understanding WHAT changed to explain WHY it changed.

### Content & Logic (Focus on WHY, not WHAT)

The commit body exists to explain the *reasoning* behind changes. The diff shows *what* changed - your job is to explain *why*.

Structure: Follow the "Problem -> Solution -> Rationale" pattern:

- Paragraph 1 - The Problem: What is broken, missing, or suboptimal? What happens if this isn't fixed? Be specific about the actual issue. (e.g.,
"Currently, the driver fails to reset the hardware state after suspend, causing data corruption on resume.")

- Paragraph 2 - The Solution: Describe the approach at a conceptual level, not the code changes. Explain *why* this approach solves the problem and *why*
it was chosen over alternatives. (e.g., "Add an explicit hardware reset sequence during resume. This ensures the device returns to a known state before
accepting new commands, matching the vendor's recommended initialization flow.")

### Rules
- NO External Links: Do not include URLs (http/https) in the body. If referencing external discussion or bug report, describe it textually or reference a
Commit ID/CVE ID, but never a raw link.
- NO How: Do not describe the code changes literally (e.g., avoid saying "Change x to y"). The diff shows *how*; you must explain *why*.
- NO "Changes:" section: NEVER create bullet lists of changes. No "Changes:", "What changed:", "Modified:", or similar sections. The diff already shows
what changed - the commit message explains *why*.
- NO `ðŸ¤– Generated with Claude Code` footer - NEVER
- NO `Co-Authored-By:` lines - NEVER
- NO emoji or special characters
- NO URLs or http/https links

### Optional Related Line
- If branch name contains a ticket ID (e.g., `IOTIL-1639-...`), add `Related: IOTIL-1639` as the last line before Signed-off-by
- DON'T add "Related:" if a ticket has not been found.

### Output
- Return *only* the commit message (Subject + Body + optional Related line)
- Do not include the diff or the list of changed files in the output
- Do not include Signed-off-by (the script adds it automatically)

### Example
```commit message
iotil/rest: Add OEQA results retrieval endpoint

Currently there is no way to fetch OEQA test results through the REST
API. Users must access the database directly or parse raw attachments
to obtain structured test results, making automation and integration
with external tools impractical.

Expose a dedicated endpoint on TestRunViewSet that returns parsed OEQA
JSON results. This enables CI systems and dashboards to consume test
data programmatically without requiring direct database access or
custom parsing logic.
```"""

COMMIT_TITLE_ONLY_PROMPT = """## Generate Commit Subject Line Only

Analyze the diff and generate ONLY a single-line commit subject. Rules:

- Start with subsystem prefix based on file paths (e.g., `iotil/rest:`, `drivers/net:`)
- Imperative mood (e.g., "Fix memory leak" not "Fixed memory leak")
- Capitalize first letter after prefix
- No trailing period
- Maximum 70 characters
- NO body, NO blank lines, NO Related line, NO Signed-off-by
- Return ONLY the subject line, nothing else
- NO markdown formatting, NO code blocks

Example: iotil/rest: Add OEQA results retrieval endpoint"""


def get_commit_template(branch_name: str, ticket_number: str | None = None) -> str:
    """Get a fallback commit message template."""
    related_line = f"\nRelated: IOTIL-{ticket_number}" if ticket_number else ""
    return f"""<type>(<scope>): <subject>

<body - explain the WHY, not the WHAT>

Paragraph 1 - The Problem:
What is broken, missing, or suboptimal? What happens if this isn't fixed?

Paragraph 2 - The Solution:
Describe the approach at a conceptual level, not the code changes.
{related_line}

# Lines starting with '#' will be ignored.
# Branch: {branch_name}
#
# Commit message guidelines:
# - Subject line: imperative mood, max 70-75 chars
# - Body: wrap at 72 chars
# - Types: feat, fix, docs, style, refactor, test, chore
"""


# =============================================================================
# Commit Command Helpers
# =============================================================================


def _detect_staged_changes(repo: git.Repo, console: Console) -> tuple[str, str, list[str]]:
    """Detect staged changes, returning diff output, branch name, and staged file list."""
    import git as gitmodule

    from devtool.common.console import print_error

    try:
        head_valid = repo.head.is_valid()
    except gitmodule.exc.GitCommandError:
        head_valid = False

    if head_valid:
        staged = repo.index.diff("HEAD")
        if not staged:
            staged_new = repo.index.diff("HEAD", R=True)
            if not staged_new:
                print_error(console, "No staged changes found. Use 'git add' to stage changes.")
                sys.exit(1)
    else:
        staged = list(repo.index.diff(None))
        if not staged and not repo.index.entries:
            print_error(console, "No staged changes found. Use 'git add' to stage changes.")
            sys.exit(1)

    try:
        branch_name = repo.active_branch.name
    except TypeError:
        branch_name = repo.head.commit.hexsha[:7]

    try:
        diff_output = repo.git.diff("--cached")
    except gitmodule.exc.GitCommandError as e:
        print_error(console, f"Failed to get staged diff: {e}")
        sys.exit(1)

    if not diff_output.strip():
        print_error(console, "No staged changes found. Use 'git add' to stage changes.")
        sys.exit(1)

    staged_files_output = repo.git.diff("--cached", "--name-only")
    staged_files = [f for f in staged_files_output.split("\n") if f]

    return diff_output, branch_name, staged_files


def _apply_compression(
    diff_output: str,
    repo: git.Repo,
    config: ACAConfig,
    console: Console,
    no_compress: bool,
) -> tuple[str, dict[str, int | str] | None, str]:
    """Check diff size and apply compression if needed."""
    diff_size = calculate_diff_size(diff_output, repo)
    diff_stats = extract_diff_statistics(repo)
    needs_compression = should_compress_diff(diff_size, config)

    final_diff = diff_output
    compression_info: dict[str, int | str] | None = None
    diff_format_note = ""

    compression_enabled = config.diff_compression_enabled and not no_compress

    if no_compress and config.diff_compression_enabled:
        console.print("[yellow]âš  Compression disabled via --no-compress flag[/yellow]")

    if needs_compression and compression_enabled:
        size_kb = diff_size["bytes"] / 1024
        threshold_kb = config.diff_size_threshold_bytes / 1024
        logger.debug(
            f"Compression threshold check: size={size_kb:.1f}KB, files={diff_size['files']}, "
            f"thresholds={threshold_kb:.0f}KB/{config.diff_files_threshold} files"
        )
        console.print()
        console.print("[yellow bold]âš  Large diff detected[/yellow bold]")
        console.print()
        console.print(f"Size: {size_kb:.1f} KB, Files: {diff_size['files']}, Lines: {diff_size['lines']}")
        console.print(f"Changes: +{diff_stats['insertions']} -{diff_stats['deletions']}")
        console.print()

        strategy = config.diff_compression_strategy
        logger.debug(f"Selected compression strategy: {strategy}")

        try:
            final_diff, compression_info = apply_compression_strategy(repo, strategy, diff_output, config)

            if compression_info is None or not {"strategy", "original_size", "compressed_size"}.issubset(
                compression_info.keys()
            ):
                logger.warning("Compression produced invalid metadata, falling back to original diff")
                console.print("[yellow]âš  Compression metadata incomplete, using original diff[/yellow]")
                final_diff = diff_output
                compression_info = _fallback_compression_info(diff_output)

            if not final_diff.strip():
                logger.warning("Compression produced empty diff, falling back to original diff")
                console.print(
                    "[yellow]âš  All files matched exclusion patterns during compression, using original diff[/yellow]"
                )
                final_diff = diff_output
                compression_info["strategy"] = "none"
                compression_info["compressed_size"] = compression_info["original_size"]

        except Exception as e:
            logger.error(f"Compression failed: {e}", exc_info=True)
            console.print("[yellow]âš  Compression failed, using original diff[/yellow]")
            final_diff = diff_output
            compression_info = _fallback_compression_info(diff_output)

        actual_strategy = str(compression_info["strategy"])
        logger.debug(
            f"Compression results: strategy={actual_strategy}, "
            f"original={compression_info['original_size']}, compressed={compression_info['compressed_size']}"
        )

        if actual_strategy != "none":
            original_kb = int(compression_info["original_size"]) / 1024
            compressed_kb = int(compression_info["compressed_size"]) / 1024
            if int(compression_info["original_size"]) > 0:
                reduction_pct = (
                    1 - int(compression_info["compressed_size"]) / int(compression_info["original_size"])
                ) * 100
            else:
                reduction_pct = 0

            console.print(f"[green]Compression applied: {actual_strategy}[/green]", end="")

            if actual_strategy == "smart":
                files_full = int(compression_info.get("files_included", 0))
                files_stat = int(compression_info.get("files_excluded", 0))
                char_limit_kb = int(compression_info.get("token_limit", 100_000)) / 1024
                console.print(
                    f" | Priority: {files_full} files (full), {files_stat} files (stat) | "
                    f"Size: {compressed_kb:.1f} KB / {char_limit_kb:.0f} KB limit"
                )
            elif actual_strategy == "filtered":
                files_inc = int(compression_info.get("files_included", 0))
                files_exc = int(compression_info.get("files_excluded", 0))
                console.print(f" | Files: {files_inc} included, {files_exc} excluded | Size: {compressed_kb:.1f} KB")
            else:
                console.print(f" | Size: {compressed_kb:.1f} KB")

            console.print(
                f"[cyan]Reduced by {reduction_pct:.0f}%[/cyan] ({original_kb:.1f} KB â†’ {compressed_kb:.1f} KB)"
            )
            console.print(f"Thresholds: {threshold_kb:.0f} KB or {config.diff_files_threshold} files")
            console.print()

            diff_format_note = (
                f"\n**Diff format:** {actual_strategy} (compressed from {original_kb:.1f} KB to {compressed_kb:.1f} KB)"
            )
        else:
            console.print("[yellow]Using original diff (compression not applied)[/yellow]")
            console.print(f"Thresholds: {threshold_kb:.0f} KB or {config.diff_files_threshold} files")
            console.print()

        logger.debug(f"Final diff size for prompt: {len(final_diff.encode('utf-8')) / 1024:.1f} KB")
    else:
        logger.debug(f"Diff size within limits: {diff_size['bytes'] / 1024:.1f} KB, {diff_size['files']} files")

    return final_diff, compression_info, diff_format_note


def _build_commit_prompt(
    final_diff: str,
    branch_name: str,
    ticket_number: str | None,
    title_only: bool,
    diff_format_note: str,
) -> str:
    """Build the commit message generation prompt."""
    commit_prompt = COMMIT_TITLE_ONLY_PROMPT if title_only else COMMIT_PROMPT
    return f"""{commit_prompt}

## Git Context
- Branch: {branch_name}
- Ticket: {ticket_number or "none"}

## Staged Changes Diff{diff_format_note}
{final_diff}
"""


def _display_and_confirm_prompt(
    console: Console,
    prompt: str,
    prepared_prompt: str | None,
    prepared_temp_file: str | None,
    prompt_size_kb: float,
    yes: bool,
) -> bool:
    """Display prompt preview and ask for confirmation. Returns True to proceed."""
    from devtool.common.claude import cleanup_temp_prompt_file

    display_prompt = prepared_prompt if prepared_prompt is not None else prompt
    display_size_bytes = len(display_prompt.encode("utf-8"))
    display_size_kb = display_size_bytes / 1024
    prompt_size_bytes = int(prompt_size_kb * 1024)

    console.print()
    console.print("[bold]â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•[/bold]")
    console.print("[bold]PROMPT PREVIEW[/bold]")
    if prepared_prompt is not None:
        console.print(f"[dim]Size: {display_size_kb:.1f} KB ({display_size_bytes:,} characters)[/dim]")
        console.print(
            "[yellow]Note: File-based delivery active. Diff content is in the temp file shown below.[/yellow]"
        )
    else:
        console.print(f"[dim]Size: {prompt_size_kb:.1f} KB ({prompt_size_bytes:,} characters)[/dim]")
    console.print("[bold]â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•[/bold]")
    console.print()
    console.print(display_prompt)
    console.print()
    console.print("[bold]â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•[/bold]")
    console.print()

    if yes:
        return True

    try:
        confirm = input("Send this prompt to Claude? [y/n]: ").strip().lower()
    except EOFError, KeyboardInterrupt:
        if prepared_temp_file is not None:
            cleanup_temp_prompt_file(prepared_temp_file)
        console.print("\nAborted.")
        sys.exit(0)

    if confirm not in ("y", "yes"):
        if prepared_temp_file is not None:
            cleanup_temp_prompt_file(prepared_temp_file)
        return False

    return True


# =============================================================================
# Commit Command
# =============================================================================


@click.command()
@click.option("--no-compress", is_flag=True, help="Disable diff compression")
@click.option("--show-prompt", is_flag=True, help="Show the prompt sent to Claude")
@click.option("--yes", "-y", is_flag=True, help="Auto-confirm the generated commit message")
@click.option("--title-only", "-t", is_flag=True, help="Generate only a single-line commit title (implies --yes)")
@click.option(
    "--model",
    "-m",
    type=click.Choice(["haiku", "sonnet", "opus"], case_sensitive=False),
    default=None,
    help="Model to use (default: config commit_model, usually haiku)",
)
@click.option("--plain-text", is_flag=True, help="Output plain text without formatting")
@click.option("--verbose", "-v", is_flag=True, help="Enable verbose/debug logging")
@click.pass_context
def commit(
    ctx: click.Context,
    no_compress: bool,
    show_prompt: bool,
    yes: bool,
    title_only: bool,
    model: str | None,
    plain_text: bool,
    verbose: bool,
) -> None:
    """Generate a commit message for staged changes."""
    import git

    from devtool.common.claude import (
        cleanup_temp_prompt_file,
        create_file_based_prompt,
        should_use_file_based_prompt,
    )
    from devtool.common.config import get_config
    from devtool.common.console import (
        check_claude_cli,
        check_dependency,
        check_version_compatibility,
        get_console,
        print_error,
        print_output,
        setup_logging,
    )
    from devtool.common.git import (
        edit_in_editor,
        extract_ticket_number,
        get_precommit_skip_env,
        strip_markdown_code_blocks,
    )

    if title_only:
        yes = True

    setup_logging(verbose=verbose)
    console = get_console(plain_text)

    if not check_dependency("git", console):
        sys.exit(1)

    try:
        repo = git.Repo(search_parent_directories=True)
    except git.exc.InvalidGitRepositoryError:
        print_error(console, "Not in a git repository")
        sys.exit(1)

    diff_output, branch_name, staged_files = _detect_staged_changes(repo, console)

    if get_precommit_skip_env():
        console.print("[yellow]âš  Pre-commit hooks will be completely bypassed (validation + commit phase)[/yellow]")

    hooks_passed, modified_files = run_precommit_hooks(repo, console, staged_files)

    if not hooks_passed:
        print_error(console, "Pre-commit hooks failed. Please fix the issues and try again.")
        console.print("[yellow]Tip: Set SKIP_PRECOMMIT=1 to bypass hooks temporarily[/yellow]")
        sys.exit(1)

    if modified_files:
        console.print("\n[yellow bold]âš  Pre-commit hooks modified files:[/yellow bold]\n")
        for file in modified_files:
            console.print(f"  â€¢ {file}")
        console.print()
        console.print("[cyan]The following files were automatically formatted or modified by hooks.[/cyan]")
        console.print("[cyan]Please review the changes, stage them, and run 'devtool commit' again.[/cyan]")
        console.print()
        console.print("[dim]Next steps:[/dim]")
        console.print("  1. Review the modified files: git diff")
        console.print("  2. Stage the changes: git add <files>")
        console.print("  3. Run 'devtool commit' again")
        sys.exit(0)

    # Check Claude Code CLI
    cli_version = check_claude_cli(console)
    if cli_version is None:
        sys.exit(1)
    check_version_compatibility(console, version=cli_version)

    config = get_config()
    final_diff, compression_info, diff_format_note = _apply_compression(diff_output, repo, config, console, no_compress)

    ticket_number = extract_ticket_number(branch_name)

    prompt = _build_commit_prompt(final_diff, branch_name, ticket_number, title_only, diff_format_note)

    # Validate prompt size
    prompt_size_bytes = len(prompt.encode("utf-8"))
    prompt_size_kb = prompt_size_bytes / 1024
    max_prompt_size_kb = 200

    if prompt_size_kb > max_prompt_size_kb:
        logger.warning(f"Prompt size ({prompt_size_kb:.1f} KB) exceeds recommended limit ({max_prompt_size_kb} KB)")
        console.print()
        console.print(f"[yellow bold]âš  Large prompt size: {prompt_size_kb:.1f} KB[/yellow bold]")
        console.print(
            f"[yellow]The prompt exceeds the recommended {max_prompt_size_kb} KB limit. "
            "Consider using a more aggressive compression strategy (e.g., 'stat' or 'smart').[/yellow]"
        )
        console.print("[dim]Tip: Set ACA_DIFF_COMPRESSION_STRATEGY=stat for maximum compression[/dim]")
        console.print()

        if compression_info is None:
            console.print("[dim]Tip: Set ACA_DIFF_COMPRESSION_ENABLED=true to enable automatic compression[/dim]")
            console.print()
    else:
        logger.debug(f"Prompt size within limits: {prompt_size_kb:.1f} KB")

    # Check if file-based delivery will be used
    will_use_file_based = config.prompt_file_enabled and should_use_file_based_prompt(prompt, config)

    if will_use_file_based:
        console.print(
            f"[dim]File-based prompt delivery will be used for this large diff ({prompt_size_kb:.1f} KB)[/dim]"
        )

    # Pre-create file-based prompt if --show-prompt is set
    prepared_prompt: str | None = None
    prepared_temp_file: str | None = None

    if show_prompt and will_use_file_based:
        file_result = create_file_based_prompt(
            prompt,
            section_marker="## Staged Changes Diff",
            target_dir=str(repo.working_dir),
        )
        if file_result is not None:
            prepared_prompt, prepared_temp_file = file_result
            logger.debug(f"Pre-created file-based prompt for --show-prompt preview: {prepared_temp_file}")

    if show_prompt:
        if not _display_and_confirm_prompt(console, prompt, prepared_prompt, prepared_temp_file, prompt_size_kb, yes):
            console.print("Aborted.")
            sys.exit(0)

    # Prepare fallback template
    fallback_template = "<type>(<scope>): <subject>" if title_only else get_commit_template(branch_name, ticket_number)

    generation_prompt = prepared_prompt if prepared_prompt is not None else prompt
    skip_auto_file_delivery = prepared_prompt is not None

    def cleanup_prepared_file() -> None:
        if prepared_temp_file is not None:
            cleanup_temp_prompt_file(prepared_temp_file)

    def post_process(raw: str) -> str | None:
        msg = extract_commit_message(raw)
        if msg:
            msg = strip_markdown_code_blocks(msg)
        if title_only and msg:
            msg = truncate_title(msg)
        return msg

    from devtool.common.claude import generate_with_retry

    # Model resolution: --model flag > config.commit_model > config.default_model
    effective_model = model if model is not None else config.commit_model

    try:
        commit_message = generate_with_retry(
            console,
            generation_prompt,
            str(repo.working_dir),
            fallback_template,
            "commit title" if title_only else "commit message",
            model=effective_model,
            cleanup_fn=cleanup_prepared_file,
            skip_file_based_delivery=skip_auto_file_delivery,
            post_process_fn=post_process,
            edit_suffix=".txt",
            system_prompt="You are a commit message generator. Output only the commit message, nothing else.",
            max_turns=1,
            effort="low",
        )
    except OSError as e:
        import errno

        if e.errno == errno.E2BIG or "Argument list too long" in str(e):
            logger.error(f"ARG_MAX exceeded (OSError): {e}")
            _print_argmax_error(console, config)
            cleanup_prepared_file()
            sys.exit(1)
        raise

    # Display the generated message and prompt for action
    if yes:
        console.print("\n[bold]Generated Commit Message:[/bold]\n")
        print_output(console, commit_message, markdown=False)
        console.print()
    else:
        while True:
            console.print("\n[bold]Generated Commit Message:[/bold]\n")
            print_output(console, commit_message, markdown=False)
            console.print()

            try:
                choice = input("Do you want to (e)dit, (c)ommit, or (a)bort? [e/c/a]: ").strip().lower()
            except EOFError, KeyboardInterrupt:
                console.print("\nAborted.")
                sys.exit(0)

            if choice in ("a", "abort"):
                console.print("Commit cancelled.")
                sys.exit(0)
            elif choice in ("e", "edit"):
                commit_message = edit_in_editor(commit_message, console, ".txt")
                continue
            elif choice in ("c", "commit"):
                break
            else:
                console.print("Invalid choice. Please enter 'e', 'c', or 'a'.")
                continue

    # Execute git commit
    skip_env = get_precommit_skip_env()
    should_skip_hooks = bool(skip_env)

    commit_cmd = ["git", "commit"]
    if should_skip_hooks:
        commit_cmd.append("--no-verify")
        console.print("[yellow]âš  Committing with --no-verify (SKIP_PRECOMMIT is set)[/yellow]")
    commit_cmd.extend(["--signoff", "-m", commit_message])

    proc_result = subprocess.run(commit_cmd, capture_output=True, text=True, cwd=repo.working_dir)
    if proc_result.returncode == 0:
        console.print("[green]Commit created successfully![/green]")
        if proc_result.stdout:
            console.print(proc_result.stdout)
    else:
        print_error(console, f"Git commit failed: {proc_result.stderr}")
        sys.exit(1)


def _fallback_compression_info(diff_output: str) -> dict[str, int | str]:
    """Return compression info indicating no compression was applied."""
    size = len(diff_output.encode("utf-8"))
    return {
        "strategy": "none",
        "original_size": size,
        "compressed_size": size,
        "files_included": 0,
        "files_excluded": 0,
    }


def _print_argmax_error(console: Console, config: ACAConfig) -> None:
    """Print ARG_MAX exceeded error with guidance."""
    console.print()
    console.print("[red bold]Error: Prompt too large for command-line delivery[/red bold]")
    console.print()
    console.print(
        "[yellow]The diff is too large to pass to Claude via command-line arguments. "
        "This is a known limitation of the Claude Agent SDK.[/yellow]"
    )
    console.print()
    console.print("[bold]Possible solutions:[/bold]")
    console.print("  1. Ensure file-based delivery is enabled: ACA_PROMPT_FILE_ENABLED=true")
    console.print("  2. Use a more aggressive compression strategy: ACA_DIFF_COMPRESSION_STRATEGY=stat")
    console.print("  3. Stage fewer files and commit in smaller batches")
    console.print()
    if not config.prompt_file_enabled:
        console.print(
            "[cyan]File-based delivery is currently DISABLED. Enable it with: ACA_PROMPT_FILE_ENABLED=true[/cyan]"
        )
    else:
        console.print(
            "[dim]File-based delivery is enabled but may have failed. "
            "Check logs with ACA_LOG_LEVEL=DEBUG for details.[/dim]"
        )
